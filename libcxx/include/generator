// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_GENERATOR
#define _LIBCPP_GENERATOR

#include <__assert>
#include <__concepts/constructible.h>
#include <__config>
#include <__coroutine/coroutine_handle.h>
#include <__coroutine/noop_coroutine_handle.h>
#include <__coroutine/trivial_awaitables.h>
#include <__exception/exception_ptr.h>
#include <__iterator/default_sentinel.h>
#include <__memory/addressof.h>
#include <__memory/allocator_traits.h>
#include <__ranges/elements_of.h>
#include <__ranges/view_interface.h>
#include <__type_traits/add_pointer.h>
#include <__type_traits/conditional.h>
#include <__type_traits/is_nothrow_constructible.h>
#include <__type_traits/is_reference.h>
#include <__type_traits/is_void.h>
#include <__type_traits/remove_cvref.h>
#include <__utility/exchange.h>
#include <__utility/swap.h>

#if _LIBCPP_STD_VER >= 23

_LIBCPP_BEGIN_NAMESPACE_STD

struct alignas(__STDCPP_DEFAULT_NEW_ALIGNMENT__) __aligned_block {
  unsigned char data[__STDCPP_DEFAULT_NEW_ALIGNMENT__];
};

template <class _Allocator = void>
class __coroutine_allocator {
private:
  using __alloc_t = __rebind_alloc<_Allocator, __aligned_block>::type;

  static void* __allocate(__alloc_t __allocator, const size_t __size) {
    if constexpr (default_initializable<__alloc_t> && allocator_traits<__alloc_t>::is_always_equal::value) {
    }
  }

public:
};

template <class _Ref, class _Val>
using __gen_val = conditional_t<is_void_v<_Val>, remove_cvref_t<_Ref>, _Val>;

template <class _Ref, class _Val>
using __gen_ref = conditional_t<is_void_v<_Val>, _Ref&&, _Ref>;

template <class _Ref, class _Val>
using __gen_yielded =
    conditional_t<is_reference_v<__gen_ref<_Ref, _Val>>, __gen_ref<_Ref, _Val>, const __gen_ref<_Ref, _Val>&>;

template <class, class, class>
class generator;

template <class _Yielded>
class __gen_promise_base {
private:
  struct __root_data {
    add_pointer_t<_Yielded> __value_ptr;
    std::coroutine_handle<__gen_promise_base> __active;
  };

  struct __recursive_data {
    std::exception_ptr __exception;
    std::coroutine_handle<__gen_promise_base> __parent;
    std::coroutine_handle<__gen_promise_base> __root;
  };

  union {
    __root_data __root;
    __recursive_data __recursive;
  } __data_;
  bool __tag_ = false;

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI bool __is_root() noexcept { return !__tag_; }
  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI __root_data* __get_root_data() noexcept {
    _LIBCPP_ASSERT_INTERNAL(__is_root(), "todo");
    return &__data_.__root;
  }
  _LIBCPP_HIDE_FROM_ABI void __set_root_tag() noexcept { __tag_ = false; }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI bool __is_recursive() noexcept { return __tag_; }
  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI __recursive_data* __get_recursive_data() noexcept {
    _LIBCPP_ASSERT_INTERNAL(__is_recursive(), "todo");
    return &__data_.__recursive;
  }
  _LIBCPP_HIDE_FROM_ABI void __set_recursive_tag() noexcept { __tag_ = true; }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI add_pointer_t<_Yielded>& __value_ptr() noexcept {
    _LIBCPP_ASSERT_INTERNAL(__is_root(), "todo");
    return __data_.__get_root_data().__value_ptr;
  }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI add_pointer_t<_Yielded>& __root_value_ptr() noexcept {
    if (__data_.__is_root()) {
      return __value_ptr();
    }
    return __data_.__get_recursive_data().__root.promise().__value_ptr();
  }

  class __element_awaiter {
  public:
    [[nodiscard]] constexpr bool await_ready() const noexcept { return false; }

    template <class _Promise>
    constexpr void await_suspend(coroutine_handle<_Promise> __current) noexcept {
      __current.promise().__root_value_ptr() = std::addressof(__value_);
    }

    constexpr void await_resume() const noexcept {}

  private:
    remove_cvref_t<_Yielded> __value_;
  };

  class __final_awaiter {
  public:
    [[nodiscard]] constexpr bool await_ready() const noexcept { return false; }

    template <class _Promise>
    constexpr coroutine_handle<> await_suspend(coroutine_handle<_Promise> __current) noexcept {
      if (__current.promise().__is_recursive()) {
        auto __recursive_data = __current.promise().__get_recursive_data();
        auto __parent         = __recursive_data.__parent;
        auto __root_data      = __recursive_data.__root.promise().__get_root_data();
        __root_data.__active  = __parent;
        return __parent;
      }
      return std::noop_coroutine();
    }

    constexpr void await_resume() const noexcept {}
  };

  template <class _Ref, class _Val, class _Allocator>
  class __nested_awaiter {
  private:
    generator<_Ref, _Val, _Allocator> __gen_;

  public:
    explicit __nested_awaiter(generator<_Ref, _Val, _Allocator>&& __gen) noexcept : __gen_(std::move(__gen)) {}

    [[nodiscard]] constexpr bool await_ready() const noexcept { return !__gen_.__coroutine_; }

    template <class _Promise>
    constexpr coroutine_handle<__gen_promise_base> await_suspend(coroutine_handle<_Promise> __current) noexcept {
      auto __recursive = coroutine_handle<__gen_promise_base>::from_address(__gen_.__coroutine_.address());
      __recursive.promise().__set_recursive_tag();
      auto __recursive_data = __recursive.promise().__get_recursive_data();

      auto __parent              = coroutine_handle<__gen_promise_base>::from_address(__current.address());
      __recursive_data.__parent_ = __parent;
      if (__parent.__is_recursive()) {
        __recursive_data.__root = __parent.promise().__get_recursive_data().__root;
      } else {
        __recursive_data.__root = __parent;
      }

      auto __root_data     = __recursive_data.__root.promise().__get_root_data();
      __root_data.__active = __recursive;
      return __recursive;
    }

    void await_resume() {
      auto __recursive      = coroutine_handle<__gen_promise_base>::from_address(__gen_.__coroutine_.address());
      auto __recursive_data = __recursive.promise().__get_recursive_data();
      if (__recursive_data.__exception) {
        std::rethrow_exception(std::move(__recursive_data.__exception));
      }
    }
  };

public:
  suspend_always initial_suspend() const noexcept { return {}; }

  auto final_suspend() noexcept { return __final_awaiter{}; }

  suspend_always yield_value(_Yielded __val) noexcept {
    __root_value_ptr() = addressof(__val);
    return {};
  }

  auto yield_value(const remove_reference_t<_Yielded>& __val)
    requires is_rvalue_reference_v<_Yielded> &&
             constructible_from<remove_cvref_t<_Yielded>, const remove_reference_t<_Yielded>&>
  {
    return __element_awaiter(__val);
  }

  void await_transform() = delete;

  void return_void() const noexcept {}

  void unhandled_exception() {
    if (__is_root()) {
      throw;
    } else {
      auto __recursive_data         = __get_recursive_data();
      __recursive_data->__exception = std::current_exception();
    }
  }
};

template <class _Ref, class _Val>
class __gen_iter {
private:
  using __val = __gen_val<_Ref, _Val>;
  using __ref = __gen_ref<_Ref, _Val>;

public:
  using value_type      = __val;
  using difference_type = ptrdiff_t;

  struct promise_type {};

  __gen_iter(__gen_iter&& __other) noexcept : __coroutine_(std::exchange(__other.__coroutine_, {})) {}

  __gen_iter& operator=(__gen_iter&& __other) noexcept {
    __coroutine_ = std::exchange(__other.__coroutine_, {});
    return *this;
  }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI __ref operator*() const noexcept(is_nothrow_copy_constructible_v<__ref>) {
    // todo: return static_cast<__reference_t>();
  }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI __gen_iter& operator++() {
    // todo
  }

  _LIBCPP_HIDE_FROM_ABI void operator++(int) { ++*this; }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI bool operator==(default_sentinel_t) { return __coroutine_.done(); }

private:
  _LIBCPP_HIDE_FROM_ABI explicit __gen_iter(coroutine_handle<promise_type> __coroutine) noexcept
      : __coroutine_(std::move(__coroutine)) {}

  coroutine_handle<promise_type> __coroutine_;
};

template <class _Ref, class _Val = void, class _Allocator = void>
class generator : public ranges::view_interface<generator<_Ref, _Val, _Allocator>> {
private:
  using __val = __gen_val<_Ref, _Val>;

  using __ref = __gen_ref<_Ref, _Val>;

  friend __gen_iter<_Ref, _Val>;

public:
  using yielded = __gen_yielded<_Ref, _Val>;

  class promise_type;

  _LIBCPP_HIDE_FROM_ABI generator(const generator&) = delete;
  _LIBCPP_HIDE_FROM_ABI generator(generator&& __other) noexcept
      : __coroutine_(std::exchange(__other.__coroutine_, {})) {}

  _LIBCPP_HIDE_FROM_ABI ~generator() {
    if (__coroutine_) {
      __coroutine_.destroy();
    }
  }

  _LIBCPP_HIDE_FROM_ABI generator& operator=(generator __other) noexcept {
    std::swap(__coroutine_, __other.__coroutine_);
    return *this;
  }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI __gen_iter<_Ref, _Val> begin() {
    __coroutine_.resume();
    return __gen_iter(__coroutine_);
  }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI default_sentinel_t end() const noexcept { return default_sentinel; }

private:
  coroutine_handle<promise_type> __coroutine_ = nullptr;
};

_LIBCPP_END_NAMESPACE_STD

#endif

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

#endif
