// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_GENERATOR
#define _LIBCPP_GENERATOR

#include <__concepts/constructible.h>
#include <__config>
#include <__coroutine/coroutine_handle.h>
#include <__iterator/default_sentinel.h>
#include <__memory/allocator_traits.h>
#include <__ranges/elements_of.h>
#include <__ranges/view_interface.h>
#include <__type_traits/conditional.h>
#include <__type_traits/is_nothrow_constructible.h>
#include <__type_traits/is_reference.h>
#include <__type_traits/is_void.h>
#include <__type_traits/remove_cvref.h>
#include <__utility/exchange.h>
#include <__utility/swap.h>

#if _LIBCPP_STD_VER >= 23

_LIBCPP_BEGIN_NAMESPACE_STD

struct alignas(__STDCPP_DEFAULT_NEW_ALIGNMENT__) __aligned_block {
  unsigned char data[__STDCPP_DEFAULT_NEW_ALIGNMENT__];
};

template <class _Allocator = void>
class __coroutine_allocator {
private:
  using __alloc_t = __rebind_alloc<_Allocator, __aligned_block>::type;

  static void* __allocate(__alloc_t __allocator, const size_t __size) {
    if constexpr (default_initializable<__alloc_t> && allocator_traits<__alloc_t>::is_always_equal::value) {
      
    }
  }

public:
};

template <class _Ref, class _Val = void, class _Allocator = void>
class generator : public ranges::view_interface<generator<_Ref, _Val, _Allocator>> {
private:
  using __value_t = conditional_t<is_void_v<_Val>, remove_cvref_t<_Ref>, _Val>;

  using __reference_t = conditional_t<is_void_v<_Val>, _Ref&&, _Ref>;

  class __iterator;

public:
  using yielded = conditional_t<is_reference_v<__reference_t>, __reference_t, const __reference_t&>;

  class promise_type;

  _LIBCPP_HIDE_FROM_ABI generator(const generator&) = delete;
  _LIBCPP_HIDE_FROM_ABI generator(generator&& __other) noexcept
      : __coroutine_(std::exchange(__other.__coroutine_, {})) {}

  _LIBCPP_HIDE_FROM_ABI ~generator() {
    if (__coroutine_) {
      __coroutine_.destroy();
    }
  }

  _LIBCPP_HIDE_FROM_ABI generator& operator=(generator __other) noexcept {
    std::swap(__coroutine_, __other.__coroutine_);
    return *this;
  }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI __iterator begin() { __coroutine_.resume(); }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI default_sentinel_t end() const noexcept { return default_sentinel; }

private:
  coroutine_handle<promise_type> __coroutine_ = nullptr;
};

template <class _Ref, class _Val, class _Allocator>
class generator<_Ref, _Val, _Allocator>::__iterator {
public:
  using value_type      = __value_t;
  using difference_type = ptrdiff_t;

  __iterator(__iterator&& __other) noexcept : __coroutine_(std::exchange(__other.__coroutine_, {})) {}

  __iterator& operator=(__iterator&& __other) noexcept {
    __coroutine_ = std::exchange(__other.__coroutine_, {});
    return *this;
  }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI __reference_t operator*() const
      noexcept(is_nothrow_copy_constructible_v<__reference_t>);

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI __iterator& operator++();

  _LIBCPP_HIDE_FROM_ABI void operator++(int) { ++*this; }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI bool operator==(default_sentinel_t) { return __coroutine_.done(); }

private:
  coroutine_handle<promise_type> __coroutine_;
};

_LIBCPP_END_NAMESPACE_STD

#endif

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

#endif
